* Escrever resumo high-level da prova

We define Points as an opaque type, they are not explicitly described,
and we can't ‘look inside’ them.

With the exception of Points, in Lean we represent the geometric
objects by their constructions (or deconstructions, depending on how
you look at it).

A pair of points form a Segment; in Lean, this is a structure
containing the two points, together with a proof that they are
different from other (i.e., not the same point). A PolySegment is
isomorphic to a list of Segments, having a constructor for the empty
PolySegment, a constructor that raises a Segment into a singleton
PolySegment, and one that joins two PolySegments into one.

A Face is a pair of PolySegments and a proof that they form a Jordan
curve. A PolyFace is isomorphic to a list of Faces, having a
constructor for the empty PolyFace, a constructor that raises a Face
into a singleton PolyFace, and one that joins two PolyFaces into one.

A Volume is a pair of PolyFaces together with a proof that they form a
closed volume. A PolyVolume is isomorphic to a list of Volumes, having
a constructor for the empty PolyVolume, a constructor that raises a
Volume into a singleton PolyVolume, and one that joins two PolyVolumes
into one.

A TruncationOf an object is contructed recursively. The base case is
that for any non-empty version of the object, the empty version is a
TruncationOf it. So for the case of PolyVolumes, for any non-empty
PolyVolume the empty PolyVolume is a TruncationOf it. Then, given two
objects, the first of which is TruncationOf the second one, we have
that the join of the first object with any third object is a
TruncationOf the second one with the same third object (provided we
can perform both joins, that is, their results are well-formed
geometric objects).

Given two PolyVolumes $q$ and $p$ and a constructive proof that the
$q$ is a TruncationOf $p$, we can derive Zolt's theorem by induction
on the TruncationOf construction: in the base case, we have that $q$
is the empty PolyVolume $\varepsilon$, and so we use the
$\varepsilon_2$ rule to show that $\varepsilon < p$. In the inductive
case we have that $p$ and $q$ are actually $p';r$ and $q;r$, and we
have a proof of $q' < p'$. With this proof and a trivial proof that $r
\leq r$ we can invoke the $lt_1$ rule to show that $q';r < p';r
\square$.

* Comments
** cmp and join
Ok, so cmp and join are polymorphic ways of saying that two objects
may be joined in one and joining them (respectively). We need to have
an identity between the polymorphic join and the actual join, which we
don't. Can we make cmp and join operations of a typeclass so that the
theorems would be generic over them? Can we start over with just the T
type and put everything under it?
#+begin_src
type mismatch
  lt.ε₂ ?m.21367 ?m.21368
has type
  lt (V wf₂) (join ?m.21365 (V wf₂)) : Prop
but is expected to have type
  lt (V wf₂) (V wf₁) : Prop
#+end_src
** Dependently-typing structures
if we want to prove something like
: theorem segment_comm : Segment p1 p2 → Segment p2 p1
for Face & Volume we need to add their fields to the type (e.g.,
~Volume f₁ f₂~ instead of just ~Volume~). But then we have the
problems that we have with PolySegment-related predicates: instead of
~IsJordan_comm~ being just
#+begin_src lean4
  axiom IsJordan_comm {ps₁ : PolySegment} {ps₂ : PolySegment}
    : IsJordan ps₁ ps₂ → IsJordan ps₂ ps₁
#+end_src
it is
#+begin_src lean4
axiom IsJordan_comm
  : ∀ {p₁ q₁ p₂ q₂ p₃ q₃ p₄ q₄ : Point}
      {t : Segment p₁ q₁} {s : Segment p₂ q₂}
      {u : Segment p₃ q₃} {r : Segment p₄ q₄}
      {ps₁ : PolySegment t s} {ps₂ : PolySegment u r}
  , IsJordan ps₁ ps₂ → IsJordan ps₂ ps₁
#+end_src


* Links
** Background
https://en.wikipedia.org/wiki/Mereology
https://en.wikipedia.org/wiki/Curve#Jordan

** Lean
https://github.com/vaibhavkarve/leanteach2020/blob/master/src/euclid.lean
https://wiki.illinois.edu/wiki/display/LT2020/Euclid%27s+axioms
https://www.youtube.com/watch?v=K-kLck8BvDM
https://github.com/Ja1941/hilberts-axioms/blob/master/src/incidence/basic.lean

** Already published
https://oquenosfazpensar.fil.puc-rio.br/index.php/oqnfp/article/view/802
https://www.cambridge.org/core/journals/review-of-symbolic-logic/article/abs/de-zolts-postulate-an-abstract-approach/740479194321D18DE7FC0DE9168F8D02


* Meetings
** <2023-01-25 Wed>
- [x] descobrir como abrir o envelope do PolySegment no construtor s₂
  para pegar o outermost Segment
  - não abre, só coloca o último (ou todos) segment como parâmetro do
    tipo
- como definir um predicado opaco?
  - usar =opaque= parece funcionar…

- pra definir $\frak{T}$ a melhor opção parece ser um tipo união, ou
  então precisaremos de quebrar várias regras em 4 versões (oq não
  necessariamente é tão ruim, mas é repetitivo)
** <2023-02-15 Wed>
- na prova do teorema de Zolt, a truncagem deve ser um elemento de $v$
  (i.e., uma decomposição bem-formada), mas a nossa definição de
  truncagem não leva em conta que uma truncagem qualquer pode ter um
  resultado mal-formado. Temos de garantir então que a truncagem tenha
  um resultado bem-formado.
